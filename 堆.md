#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

![image-20211026170952835](figs/image-20211026170952835.png)

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        heap = []
        # nums [1 2 3 4]
        # python 构建的是小根堆
        # 我们要维护大根堆，需要把元素变成负的
        for x in nums:
            heapq.heappush(heap, -x)
        
        # 此时heap是[-4 -3 -2 -1]
        # 需要弹出不需要的元素，保证根堆的头节点是第k个
        # 如果k是2，我们需要返回的是3
        for _ in range(k-1):
            heapq.heappop(heap)
        # 此时heap是[-3 -2 -1]
        return -heap[0]
```

```python
# 对解集空间做二分，因为定义了每个元素的范围是-1e4 <= nums[i] <= 1e4
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        left, right = int(-1e4), int(1e4) + 1
        while left < right:
            mid = left + (right - left) // 2
            cnt = self.greaterTargetCount(nums, mid)
            if cnt >= k:
                left = mid + 1
            else:
                right = mid
        return left - 1
        
    def greaterTargetCount(self, nums, target):
        cnt = 0
        for x in nums:
            if x >= target:
                cnt += 1
        return cnt
```

```python
# 快排思想
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        def randomized_partition(nums, left, right):
            index = random.randint(left, right)
            pivot = nums[index]
            nums[index], nums[left] = nums[left], nums[index]
            while left < right:
                while left < right and nums[right] >= pivot:
                    right -= 1
                nums[left] = nums[right]
                while left < right and nums[left] <= pivot:
                    left += 1
                nums[right] = nums[left]
            nums[left] = pivot
            return left
        
        def topk_split(nums, left, right, k):
            # 小到大排序
            if left >= right:
                return
            # nums index左边是前k个小的数，index右边是n-k个大的数
            index = randomized_partition(nums, left, right)
            topk_split(nums, index + 1, right, k)
            topk_split(nums, left, index - 1, k)

        # 题目要第k大的数，我们转换为第len(nums)-k小的数
        topk_split(nums, 0, len(nums)-1, len(nums)-k)
        return nums[len(nums) - k]
```

