#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

![image-20211006111544753](figs/image-20211006111544753.png)

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        path = []
        res = []
        self.backtrack(path, res, 1, k, n)
        return res

    def backtrack(self, path, res, start, k, n):
        if k == 0:
            res.append(path[:])
            return

        for i in range(start, n + 1):
            self.backtrack(path + [i], res, i + 1, k - 1, n)
```

#### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

![image-20211006112231616](figs/image-20211006112231616.png)

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        res = []
        path = []

        def backtrack(path, k, target, start):
            if target == 0 and k == 0:
                res.append(path[:])
                return 
            
            if target < 0 or k < 0:
                return
            
            for i in range(start, 10):
                backtrack(path + [i], k - 1, target - i, i + 1)
        
        backtrack(path, k, n, 1)
        return res
```

#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

![image-20211006114117779](figs/image-20211006114117779.png)

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        dic = {
            '0': (),
            '1': (),
            '2': ('a', 'b', 'c'),
            '3': ('d', 'e', 'f'),
            '4': ('g', 'h', 'i'),
            '5': ('j', 'k', 'l'),
            '6': ('m', 'n', 'o'),
            '7': ('p', 'q', 'r', 's'),
            '8': ('t', 'u', 'v'),
            '9': ('w', 'x', 'y', 'z')
        }

        res = []
        path = ""
        
        def backtrack(path, idx_num):
            if len(path) == len(digits):
                if path != "":
                    res.append(path)
                return

            alphas = dic[digits[idx_num]]
            for i in range(len(alphas)):
                backtrack(path + alphas[i], idx_num + 1)
        
        backtrack(path, 0)
        return res
```

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

![image-20211007141235700](figs/image-20211007141235700.png)

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        path = []
        res = []

        def backtrack(path, target, start):
            if target == 0:
                res.append(path[:])
                return
            elif target < 0:
                return
            
            for i in range(start, len(candidates)):
                backtrack(path + [candidates[i]], target - candidates[i], i)
        
        backtrack(path, target, 0)
        return res
```

#### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

![image-20211007142352430](figs/image-20211007142352430.png)

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        path = []
        res = []

        def backtrack(path, target, start):
            if target == 0:
                res.append(path[:])
                return
            if target < 0:
                return
            
            for i in range(start, len(candidates)):
                if i > start and candidates[i] == candidates[i-1]:
                    continue
                
                backtrack(path + [candidates[i]], target - candidates[i], i + 1)
        
        backtrack(path, target, 0)
        return res
```

#### [131. 分割回文串:star::star::star:](https://leetcode-cn.com/problems/palindrome-partitioning/)

![image-20211007151047612](figs/image-20211007151047612.png)

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res = []
        path = []

        def backtrack(path, start):
            if start >= len(s):
                res.append(path[:])
                return
            
            for i in range(start, len(s)):
                p = s[start: i + 1]
                if self.check(p):
                    backtrack(path + [p], i + 1)
        
        backtrack(path, 0)
        return res

    def check(self, s):
        i, j = 0, len(s)-1
        while i < j:
            if s[i] != s[j]:
                return False
            
            i += 1
            j -= 1
        return True
```

#### [93. 复原 IP 地址:star::star::star:](https://leetcode-cn.com/problems/restore-ip-addresses/)

![image-20211008140849347](figs/image-20211008140849347.png)

```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        path = []
        res = []

        def check(s):
            if len(s) > 1 and s[0] == '0': return False
            if int(s) > 255: return False
            if len(s) > 3: return False
            return True

        def backtrack(path, start, total_len):
            if len(path) > 4:
                return

            if total_len == len(s) and len(path) == 4:
                res.append('.'.join(path))
                return
            
            if total_len > len(s):
                return

            for i in range(1, 4):
                if start + i > len(s): 
                    break
                substr = s[start: start + i]
                if check(substr):
                    backtrack(path + [substr], start + i, total_len + i)
                else:
                    break
        backtrack(path, 0, 0)
        return res
```

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

![image-20211008141751400](figs/image-20211008141751400.png)

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        path = []
        res = []

        def backtrack(path, start):
            res.append(path[:])
            if start >= len(nums):
                return

            for i in range(start, len(nums)):
                backtrack(path + [nums[i]], i + 1)
        
        backtrack(path, 0)
        return res
```

#### [90. 子集 II:star::star:](https://leetcode-cn.com/problems/subsets-ii/)

![image-20211008143243376](figs/image-20211008143243376.png)

```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []

        def backtrack(path, start):
            res.append(path[:])

            if start >= len(nums):
                return

            for i in range(start, len(nums)):
                if i > start and nums[i] == nums[i-1]:  # 一定要注意，是i>start 不是i>0
                    continue
                
                backtrack(path + [nums[i]], i + 1)
        
        # 需要先排序
        nums.sort()
        backtrack(path, 0)
        return res
```

