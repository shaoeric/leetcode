#### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

<img src="figs/image-20220113215322348.png" alt="image-20220113215322348" style="zoom:50%;" />

```python
class Solution:
    def fib(self, n: int) -> int:
        if n <= 1:
            return n
        a, b = 0, 1
        for i in range(2, n + 1):
            a, b = b, a + b
        return b
```

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

<img src="figs/image-20220113215717976.png" alt="image-20220113215717976" style="zoom:50%;" />

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n
        dp = [0] * (n + 1)
        dp[1] = 1
        dp[2] = 2
        for i in range(3, n + 1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[-1]
```

#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

<img src="figs/image-20220115102631591.png" alt="image-20220115102631591" style="zoom:67%;" />

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0] * n for _ in range(m)]
        for i in range(n):
            dp[0][i] = 1
        for i in range(m):
            dp[i][0] = 1
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```

#### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

<img src="figs/image-20220115103136607.png" alt="image-20220115103136607" style="zoom:67%;" />

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        dp = [[0] * n for _ in range(m)]
        for i in range(n):
            if obstacleGrid[0][i] == 1: break
            dp[0][i] = 1
        for i in range(m):
            if obstacleGrid[i][0] == 1: break
            dp[i][0] = 1
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 1:
                    continue
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```

#### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

<img src="figs/image-20220115104108912.png" alt="image-20220115104108912" style="zoom:67%;" />

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[1] = 1
        dp[2] = 1
        for i in range(3, n + 1):
            for j in range(1, i):
                dp[i] = max(dp[i], j * (i-j), j * dp[i-j])
        return dp[-1]
```

#### [96. 不同的二叉搜索树:star::star:](https://leetcode-cn.com/problems/unique-binary-search-trees/)

<img src="figs/image-20220115105339462.png" alt="image-20220115105339462" style="zoom:67%;" />

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2, n + 1):
            for j in range(i):
                dp[i] += dp[j] * dp[i - j - 1]
        return dp[-1]
```

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

<img src="figs/image-20220116102415212.png" alt="image-20220116102415212" style="zoom:67%;" />

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        s = sum(nums)
        if s % 2 == 1: return False
        s = s // 2
        dp = [0] * (s+1)  # [0, 1, 2, ...11]

        for i in range(len(nums)):
            for j in range(s, -1, -1):  # [10, 9, ...0]
                if j < nums[i]: continue

                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])
        return dp[-1] == s
```

#### [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

<img src="figs/image-20220116103300974.png" alt="image-20220116103300974" style="zoom:67%;" />

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        s = sum(stones)
        target = s // 2
        dp = [0] * (target + 1)
        for i in range(len(stones)):
            for j in range(target, stones[i] - 1, -1):
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])
        return (s - dp[target]) - dp[target]
```

