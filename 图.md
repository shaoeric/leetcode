#### [207. 课程表:star::star::star:](https://leetcode-cn.com/problems/course-schedule/)

![image-20211105145955152](figs/image-20211105145955152.png)

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = [[] for _ in range(numCourses)]
        for p in prerequisites:
            graph[p[1]].append(p[0])
        # visited: 0未探索  1探索中 2已完成
        visited = [0] * numCourses
        self.has_circle = False

        def backtrack(cur):
            if visited[cur] == 1:
                self.has_circle = True
                return
			# 将当前节点状态 置为探索中
            visited[cur] = 1
            for i in graph[cur]:
                if visited[i] == 0:
                    backtrack(i)
                    if self.has_circle:
                        return
                elif visited[i] == 1:
                    self.has_circle = True
                    return
            # 整个支路都走完，将当前节点状态改为已完成
            visited[cur] = 2

        
        for i in range(numCourses):
            if visited[i] == 0 and not self.has_circle:
                backtrack(i)
                if self.has_circle:
                    return False
        return True
```

```python
# 广度优先 推荐
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        # 广度优先
        # 统计每个节点的入度，我们只能从入度为0的节点开始
        # 访问了入度为0的节点后，将其连接的节点的入度-1
        # 直到最终全都访问完
        In = [0] * numCourses
        graph = [[] for _ in range(numCourses)]
        for p in prerequisites:
            graph[p[1]].append(p[0])
            In[p[0]] += 1
        q = []
        for i in range(numCourses):
            if In[i] == 0:
                q.append(i)
        
        while q:
            v = q.pop(0)
            for child in graph[v]:
                In[child] -= 1
                if In[child] == 0:
                    q.append(child)
        return all(not In[i] for i in range(numCourses))
```

#### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

![image-20211105165038265](figs/image-20211105165038265.png)

```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        In = [0] * numCourses
        graph = [[] for _ in range(numCourses)]
        for p in prerequisites:
            graph[p[1]].append(p[0])
            In[p[0]] += 1
        q = []
        for i in range(numCourses):
            if In[i] == 0:
                q.append(i)
        
        ans = []
        while q:
            v = q.pop(0)
            ans.append(v)
            for child in graph[v]:
                In[child] -= 1
                if In[child] == 0:
                    q.append(child)

        # 长度一致 说明没有环，都添加到ans中了
        if len(ans) == numCourses:
            return ans
        else:
            return []
```

#### [802. 找到最终的安全状态](https://leetcode-cn.com/problems/find-eventual-safe-states/)

![image-20211106145832199](figs/image-20211106145832199.png)

```python
class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        # 正常的拓扑排序是找到所有入度为0的节点，然后去做BFS
        # 此题，是出度为0的节点是安全点，所有可以到达安全点的节点也是安全点
        # 因此要反向拓扑排序，因此要建立反图
        edge = [[] for _ in range(len(graph))]
        out = [0] * len(graph)
        for i, nodes in enumerate(graph):
            for node in nodes:
                edge[node].append(i)
                out[i] += 1

        q = []
        for i in range(len(graph)):
            if out[i] == 0:
                q.append(i)
        while q:
            node = q.pop(0)
            for v in edge[node]:
                out[v] -= 1
                if out[v] == 0:
                    q.append(v)
        return [i for i in range(len(out)) if out[i] == 0]
```

#### [785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)

![image-20211106152721233](figs/image-20211106152721233.png)

```python
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        uncolored, red, green = 0, 1, 2
        color = [uncolored] * n
        # 遍历所有节点，因为可能存在不连通的情况
        for i in range(n):
            if color[i] == uncolored:
                q = [i]
                while q:
                    node = q.pop(0)
                    # 邻接节点的正确的颜色
                    color_neighbor = green if color[node] == red else red
                    for v in graph[node]:
                        if color[v] == uncolored:
                            color[v] = color_neighbor
                            q.append(v)
                        # 如果邻接节点颜色不正确，说明无法二分
                        elif color[v] != color_neighbor:
                            return False
        return True
```

