#### [207. 课程表:star::star::star:](https://leetcode-cn.com/problems/course-schedule/)

![image-20211105145955152](figs/image-20211105145955152.png)

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = [[] for _ in range(numCourses)]
        for p in prerequisites:
            graph[p[1]].append(p[0])
        # visited: 0未探索  1探索中 2已完成
        visited = [0] * numCourses
        self.has_circle = False

        def backtrack(cur):
            if visited[cur] == 1:
                self.has_circle = True
                return
			# 将当前节点状态 置为探索中
            visited[cur] = 1
            for i in graph[cur]:
                if visited[i] == 0:
                    backtrack(i)
                    if self.has_circle:
                        return
                elif visited[i] == 1:
                    self.has_circle = True
                    return
            # 整个支路都走完，将当前节点状态改为已完成
            visited[cur] = 2

        
        for i in range(numCourses):
            if visited[i] == 0 and not self.has_circle:
                backtrack(i)
                if self.has_circle:
                    return False
        return True
```

```python
# 广度优先 推荐
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        # 广度优先
        # 统计每个节点的入度，我们只能从入度为0的节点开始
        # 访问了入度为0的节点后，将其连接的节点的入度-1
        # 直到最终全都访问完
        In = [0] * numCourses
        graph = [[] for _ in range(numCourses)]
        for p in prerequisites:
            graph[p[1]].append(p[0])
            In[p[0]] += 1
        q = []
        for i in range(numCourses):
            if In[i] == 0:
                q.append(i)
        
        while q:
            v = q.pop(0)
            for child in graph[v]:
                In[child] -= 1
                if In[child] == 0:
                    q.append(child)
        return all(not In[i] for i in range(numCourses))
```

#### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

![image-20211105165038265](figs/image-20211105165038265.png)

```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        In = [0] * numCourses
        graph = [[] for _ in range(numCourses)]
        for p in prerequisites:
            graph[p[1]].append(p[0])
            In[p[0]] += 1
        q = []
        for i in range(numCourses):
            if In[i] == 0:
                q.append(i)
        
        ans = []
        while q:
            v = q.pop(0)
            ans.append(v)
            for child in graph[v]:
                In[child] -= 1
                if In[child] == 0:
                    q.append(child)

        # 长度一致 说明没有环，都添加到ans中了
        if len(ans) == numCourses:
            return ans
        else:
            return []
```

