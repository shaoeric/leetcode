#### [207. 课程表:star::star::star:](https://leetcode-cn.com/problems/course-schedule/)

![image-20211105145955152](figs/image-20211105145955152.png)

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = [[] for _ in range(numCourses)]
        for p in prerequisites:
            graph[p[1]].append(p[0])
        # visited: 0未探索  1探索中 2已完成
        visited = [0] * numCourses
        self.has_circle = False

        def backtrack(cur):
            if visited[cur] == 1:
                self.has_circle = True
                return
			# 将当前节点状态 置为探索中
            visited[cur] = 1
            for i in graph[cur]:
                if visited[i] == 0:
                    backtrack(i)
                    if self.has_circle:
                        return
                elif visited[i] == 1:
                    self.has_circle = True
                    return
            # 整个支路都走完，将当前节点状态改为已完成
            visited[cur] = 2

        
        for i in range(numCourses):
            if visited[i] == 0 and not self.has_circle:
                backtrack(i)
                if self.has_circle:
                    return False
        return True
```

```python
# 广度优先 推荐
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        # 广度优先
        # 统计每个节点的入度，我们只能从入度为0的节点开始
        # 访问了入度为0的节点后，将其连接的节点的入度-1
        # 直到最终全都访问完
        In = [0] * numCourses
        graph = [[] for _ in range(numCourses)]
        for p in prerequisites:
            graph[p[1]].append(p[0])
            In[p[0]] += 1
        q = []
        for i in range(numCourses):
            if In[i] == 0:
                q.append(i)
        
        while q:
            v = q.pop(0)
            for child in graph[v]:
                In[child] -= 1
                if In[child] == 0:
                    q.append(child)
        return all(not In[i] for i in range(numCourses))
```

#### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

![image-20211105165038265](figs/image-20211105165038265.png)

```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        In = [0] * numCourses
        graph = [[] for _ in range(numCourses)]
        for p in prerequisites:
            graph[p[1]].append(p[0])
            In[p[0]] += 1
        q = []
        for i in range(numCourses):
            if In[i] == 0:
                q.append(i)
        
        ans = []
        while q:
            v = q.pop(0)
            ans.append(v)
            for child in graph[v]:
                In[child] -= 1
                if In[child] == 0:
                    q.append(child)

        # 长度一致 说明没有环，都添加到ans中了
        if len(ans) == numCourses:
            return ans
        else:
            return []
```

#### [802. 找到最终的安全状态:star::star::star:](https://leetcode-cn.com/problems/find-eventual-safe-states/)

![image-20211106145832199](figs/image-20211106145832199.png)

```python
class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        # 正常的拓扑排序是找到所有入度为0的节点，然后去做BFS
        # 此题，是出度为0的节点是安全点，所有可以到达安全点的节点也是安全点
        # 因此要反向拓扑排序，因此要建立反图
        edge = [[] for _ in range(len(graph))]
        out = [0] * len(graph)
        for i, nodes in enumerate(graph):
            for node in nodes:
                edge[node].append(i)
                out[i] += 1

        q = []
        for i in range(len(graph)):
            if out[i] == 0:
                q.append(i)
        while q:
            node = q.pop(0)
            for v in edge[node]:
                out[v] -= 1
                if out[v] == 0:
                    q.append(v)
        return [i for i in range(len(out)) if out[i] == 0]
```

#### [785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)

![image-20211106152721233](figs/image-20211106152721233.png)

```python
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        uncolored, red, green = 0, 1, 2
        color = [uncolored] * n
        # 遍历所有节点，因为可能存在不连通的情况
        for i in range(n):
            if color[i] == uncolored:
                color[i] = red
                q = [i]
                while q:
                    node = q.pop(0)
                    # 邻接节点的正确的颜色
                    color_neighbor = green if color[node] == red else red
                    for v in graph[node]:
                        if color[v] == uncolored:
                            color[v] = color_neighbor
                            q.append(v)
                        # 如果邻接节点颜色不正确，说明无法二分
                        elif color[v] != color_neighbor:
                            return False
        return True
```

#### [886. 可能的二分法](https://leetcode-cn.com/problems/possible-bipartition/)

![image-20211107135743666](figs/image-20211107135743666.png)

和785基本一致

```python
class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        graph = [[] for _ in range(n+1)]

        # 相邻接的节点不应该分在一组，分在一组的不应该相邻接
        for p, q in dislikes:
            graph[p].append(q)
            graph[q].append(p)
        
        ungroup, group1, group2 = 0, 1, 2
        groups = [ungroup] * (n+1)
        for i in range(1, n+1):
            # 如果节点i没有被分组
            if groups[i] == ungroup:
                # 先设置一个分组
                groups[i] = group1
                q = [i]
                while q:
                    node = q.pop(0)
                    neighbor_group = group2 if groups[node] == group1 else group1
                    for neighbor in graph[node]:
                        if groups[neighbor] == ungroup:
                            groups[neighbor] = neighbor_group
                            q.append(neighbor)
                        elif groups[neighbor] != neighbor_group:
                            return False
        return True
```

#### [310. 最小高度树:star::star::star:](https://leetcode-cn.com/problems/minimum-height-trees/)

![image-20211107150945723](figs/image-20211107150945723.png)

```python
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n == 1: return [0]
        graph = [[] for _ in range(n)]
        outdegree = [0] * n

        for p, q in edges:
            graph[p].append(q)
            graph[q].append(p)
            outdegree[p] += 1
            outdegree[q] += 1

        q = []
        # 将无向图的度为1的节点加入队列
        for i in range(n):
            if outdegree[i] == 1:
                q.append(i)

        # 拓扑排序
        res = []
        # 队列中是degree为1的节点
        while q:
            res = []
            size = len(q)
            # for循环遍历完，相当于初始的degree为1的节点全都扫过一遍，可以理解为[0 2 3]节点全都被删掉
            # 第二次遍历队列，q中只剩下了[1]
            for _ in range(size):
                node = q.pop(0)
                res.append(node)
                for j in graph[node]:
                    outdegree[j] -= 1
                    if outdegree[j] == 1:
                        q.append(j)
        return res
```

